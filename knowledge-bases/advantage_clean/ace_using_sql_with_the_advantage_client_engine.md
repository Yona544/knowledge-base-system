---
title: Ace Using Sql With The Advantage Client Engine
slug: ace_using_sql_with_the_advantage_client_engine
product: Advantage Database Server
component: Advantage Client Engine
version: "12"
category: API
original_path_html: ace_using_sql_with_the_advantage_client_engine.htm
source: Advantage CHM
tags:
  - ace
  - advantage-client-engine
checksum: 1b60a5fb57e85507b355f5f3e82c687e156be91b
---

# Ace Using Sql With The Advantage Client Engine

Using SQL with the Advantage Client Engine

Using SQL with the Advantage Client Engine

Advantage Client Engine

| Using SQL with the Advantage Client Engine  Advantage Client Engine |  |  |  |  |

This section provides an overview of how to use the SQL support provided by the Advantage Client Engine (ACE). See [Advantage SQL Engine](master_advantage_sql_engine.md) for a detailed description of the SQL language supported by Advantage. The Advantage SQL engine section also includes information about the types of cursors generated by SELECT statements.

Relational access through the Advantage Client Engine is accomplished using cursor handles (very similar to table handles) and statement handles. The following APIs are essential to the base usage of SQL through the Advantage Client Engine:

- [AdsCreateSQLStatement](ace_adscreatesqlstatement.md) accepts a connection handle and returns a new statement handle

- [AdsPrepareSQL](ace_adspreparesql.md) prepares an SQL statement for execution

- [AdsExecuteSQL](ace_adsexecutesql.md) executes an SQL statement after preparation via AdsPrepareSQL, returns a new cursor handle

- [AdsExecuteSQLDirect](ace_adsexecutesqldirect.md) combination of AdsPrepareSQL and AdsExecuteSQL

- [AdsClearSQLParams](ace_adsclearsqlparams.md) clears SQL parameters associated with a statement handle

- [AdsCloseTable](ace_adsclosetable.md) when passed a cursor handle, this API closes the cursor and frees all associated memory

- [AdsCloseSQLStatement](ace_adsclosesqlstatement.md) frees a statement handle and associated memory

- [AdsVerifySQL](ace_adsverifysql.md) verifies the validity of an SQL statement without executing it.

In addition, there are a number of APIs that can be used to change the default settings of statement handles. In general, these affect the settings used by the server when it opens base tables referenced in SQL statements.

- [AdsStmtSetTableType](ace_adsstmtsettabletype.md) sets the table type (ADT or CDX) used for base tables

- [AdsStmtSetTableRights](ace_adsstmtsettablerights.md) sets the rights checking mode used for base tables

- [AdsStmtSetTableReadOnly](ace_adsstmtsettablereadonly.md) sets the read-only flag used for base tables

- [AdsStmtSetTableLockType](ace_adsstmtsettablelocktype.md) sets the lock type (proprietary or compatible) used for base tables

- [AdsStmtSetTableCharType](ace_adsstmtsettablechartype.md) sets the character type (ANSI or OEM) used for base tables

- [AdsStmtConstrainUpdates](ace_adsstmtconstrainupdates.md) allows the user to control whether or not updates made to cursors must pass the WHERE condition

- [AdsStmtEnableEncryption](ace_adsstmtenableencryption.md) sets a password on the statement used for encrypting cursors so that all records from a SELECT statement are encrypted when they are sent across the network

- [AdsStmtDisableEncryption](ace_adsstmtdisableencryption.md) turns off statement encryption

- [AdsStmtSetTablePassword](ace_adsstmtsettablepassword.md) provides passwords for base tables used in SQL statements

- [AdsStmtClearTablePasswords](ace_adsstmtcleartablepasswords.md) clears all table passwords in a statement

The first step in executing an SQL statement via the Advantage Client Engine is to create a connection to either the Advantage Database Server (ADS) or the Advantage Local Server (ALS). This can be accomplished using [AdsConnect](ace_adsconnect.md) . Note that this example assumes it is written in C or C++ and, thus, uses the double backslash in the path. If you use a language in which the backslash is not the escape character in string constants, then the path would have a single backslash.

AdsConnect( "x:\\data\\example", &hConnection );

Next you will need to use this connection handle to obtain a statement handle:

AdsCreateSQLStatement( hConnection, &hStatement );

The choice of which API to use next will depend on the type of SQL statement being executed. If executing an SQL statement that contains parameters, a combination of AdsPrepareSQL and AdsExecuteSQL must be used. See [Parameters in SQL Statements](ace_parameters_in_sql_statements.md) for a discussion on using parameters.

In this example the next API to be called will be AdsExecuteSQLDirect. AdsExecuteSQLDirect is a combination of AdsPrepareSQL and AdsExecuteSQL, and this API is a more direct approach to executing an SQL statement when you will not be dealing with any parameters.

AdsExecuteSQLDirect( hStatement,

"SELECT \* FROM test WHERE dept = R&D AND salary < 40000",

&hCursor );

After the SQL statement has been executed, a cursor handle may be returned depending on the type of SQL statement. If the SQL statement is a Data Manipulation Language (DML) statement or a Data Definition Language (DDL) statement, then no cursor is returned. A DML statement starts with the INSERT, UPDATE, or DELETE keywords. A DDL statement starts with either the CREATE or DROP keywords. Any statement that starts with the keyword SELECT will return a cursor handle. See [Working with Cursor Handles](ace_working_with_cursor_handles.md) for a discussion on using cursor handles.

When finished with the rowset the user should free the cursor handle with a call to AdsCloseTable:

AdsCloseTable( hCursor );

The statement handle is now available for another query. If the cursor is not closed prior to a new query using the statement handle, an error will be returned. You are required to free the cursor before another cursor can be created on this statement handle. It is, however, possible to have multiple statement handles, each with an active cursor handle.
